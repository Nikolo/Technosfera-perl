Легковесный ORM DBI::ActiveRecord
====================================

Требуется реализовать набор классов `DBI::ActiveRecord`, позволяющий легко и непринужденно создавать объекты, интегрированные с таблицами базы данных.
ORM должен быть написан на основе ООП фреймворка *Mouse*. 
Для реализации следует активно использовать мета-программирование (мета-классы, трейты).

После этого следует создать приложение музыкальной библиотеки, использующее данный набор классов для работы с базой данных.

Волков бояться - в лес не ходить
--------------------

На самом деле не все так страшно, как кажется.
Данная задача носит в большей части обучающий характер, поэтому основная часть `DBI::ActiveRecord` уже реализована.
От вас же требуется:
* разобраться как все это устроено
* понять, каких методов, атрибутов, типов данных недостает
* понять, в каких местах требуется реализовать недостающую функциональность
* реализовать ее

Пример класса, использующего DBI::ActiveRecord
--------------------

```perl
package Local::MusicLib::Track;

use DBI::ActiveRecord;
use Local::MusicLib::DB::SQLite;

use DateTime;

db "Local::MusicLib::DB::SQLite";

table 'tracks';

has_field id => (
    isa => 'Int',
    auto_increment => 1,
    index => 'primary',
);

has_field name => (
    isa => 'Str',
    index => 'common',
    default_limit => 100,
);

has_field extension => (
    isa => 'Str',
);

has_field create_time => (
    isa => 'DateTime',
    serializer => sub { $_[0]->epoch },
    deserializer => sub { DateTime->from_epoch(epoch => $_[0]) },
);

has_field album_id => (
    isa => 'Int',
    index => 'common',
    default_limit => 100,
);

no DBI::ActiveRecord;
__PACKAGE__->meta->make_immutable();

1;
```

Пример класса, описывающего подключение к БД
--------------------
```perl
package Local::MusicLib::DB::SQLite;
use Mouse;
extends 'DBI::ActiveRecord::DB::SQLite';

sub _build_connection_params {
    my ($self) = @_;
    return [
        'dbi:SQLite:dbname=/tmp/muslib.db', '', '', {}
    ];
}

no Mouse;
__PACKAGE__->meta->make_immutable();

1;
```

Структура модулей DBI::ActiveRecord
--------------
`DBI::ActiveRecord` на данный момент включает в себя следующие модули:
```bash
DBI/
├── ActiveRecord
│   ├── DB
│   │   └── SQLite.pm
│   ├── DB.pm
│   ├── Object.pm
│   └── Trait
│       ├── Attribute
│       │   └── Field.pm
│       └── Class.pm
└── ActiveRecord.pm
```

* `DBI::ActiveRecord` - основной класс, через который происходит взаимодействие с внешним миром. Именно он должен подключаться в ваших пакетах, что бы сделать их объектами *ActiveRecord*.
* `DBI::ActiveRecord::Object` - базовый класс для всех объектов *ActiveRecord*.
* `DBI::ActiveRecord::Trait::Class` - роль для мета-классов объектов *ActiveRecord*.
* `DBI::ActiveRecord::Trait::Attribute::Field` - роль-трейт для описания полей таблицы БД.
* `DBI::ActiveRecord::DB` - базовый абстрактный класс-адаптер для работы с БД.
* `DBI::ActiveRecord::DB::SQLite` - базовый класс-адаптер для работы с БД SQLite.

Подробное описание каждого класса, его метод и атрибутов, можно посмотреть в perldoc.
```bash
perldoc lib/DBI/ActiveRecord.pm
```

Рекомендуемая структура модулей музыкальной библиотеки
--------------
```bash
Local/
└── MusicLib
    ├── Album.pm
    ├── Artist.pm
    ├── DB
    │   └── SQLite.pm
    └── Track.pm
```

Классы `Local::MusicLib::Album`, `Local::MusicLib::Artist`, `Local::MusicLib::Track` должны предоставлять интерфейс для работы с БД.
Классы из неймспейса `Local::MusicLib::DB::*` - описывать параметры подключения к БД.

Что реализовывать
------------
1. Набор классов музыкальной библиотеки. Пример реализации класса трека можно посмотреть в начале задания. Требования к сущностям описаны ниже.
2. Sugar-функцию has_field
3. Типы-ограничения для значений атрибутов `DBI::ActiveRecord::Trait::Attribute::Field`
4. Работа с первичным ключом. У каждой таблицы обязательно должен быть определен первчиный ключ (primary key), при чем только один. В классе описывается параметром `index => 'primary'` атрибута. 
5. Написать скрипт для тестирования музыкально библиотеки. Скрипт должен проверить для каждого объекта (трек, альбом, артист) операции вставки, выборки, обновления и удаления. Возмножно вас ждет сюрприз.
6. Класс-адаптер для работы с СУБД mysql, postgres на выбор

Музыкальная библотека
---------
Музыкальная библотека должна позволять сохранять/получать/обновлять/удалять информацию об исполнителях (*artist*), их альбомах (*album*) и композициях (*tracks*) в БД.

Далее под приложением понимается набор ваших классов `Local::MusicLib::*`.

#### Исполнитель
Для каждого исполнителя требуется хранить:
* Уникальный идентификатор
* Имя/название исполнителя
* Страна - двубуквенный код латиницей (ru, en, us и т.п)
* Время добавления. В БД должно храниться как timestamp, в приложении - как объект DateTime

Требуется обеспечить возможность выборки из БД:
* по списку идентификаторов
* по названию

#### Альбом
Для каждого альбома требуется хранить:
* Уникальный идентификатор
* Идентификатор исполнителя
* Название альбома
* Год издания
* Тип альбома: сингл, саундтрек, сборник, обычный альбом (валидацию делаем на уровне приложения)
* Время добавления. В БД должно храниться как timestamp, в приложении - как объект DateTime

Требуется обеспечить возможность выборки из БД:
* по списку идентификаторов
* по названию
* по индетификатору исполнителя
* по типу

#### Трек
Для каждого трека требуется хранить:
* Уникальный идентификатор
* Идентификатор альбома
* Название трека
* Длительность трека. В БД должно храниться как количество секунд, в приложении - как строка вида `hh:mm:ss`
* Время добавления. В БД должно храниться как timestamp, в приложении - как объект DateTime

Требуется обеспечить возможность выборки из БД:
* по списку идентификаторов
* по названию
* по индетификатору альбома
Борьба с экспортом
==================

Модули обычно экспортируют вам в пакет только требуемое, например:

```perl
use List::MoreUtils qw(any uniq);
if ( any { /foo/ } uniq @has_duplicates ) {
    # do stuff
}
```

Когда вы создаете свой модуль, следует придерживаться именно этого правила: никогда не экспортировать ничего безусловно; никогда нельзя быть уверенным, что экспортируемое имя уже не занято в пакете, куда происходит экспорт.

Если вы используете стандартный <i>Exporter</i>, то не пользуйтесь <i>@EXPORT</i> — только <i>@EXPORT_OK</i>.

Однако не все модули, даже популярные, придерживаются этого стандартного на сегодняшний день правила.

Далее я расскажу про несколько типичных случаев проблем с экспортом и варианты решения.

Погашение экспорта
------------------

Простой модуль `JSON`, несмотря на наличие объектного интерфейса, также по умолчанию экспортирует фукнкции `encode_json`, `decode_json`, `to_json`, `from_json`. В данном случае проблема легко решаема:

```perl
use JSON ();
```

Пустые скобки после `use` однозначно говорят, что функцию `import` вызывать не надо.

Как же теперь добраться до функций, экспорт которых мы предотвратили? В случае с `JSON` все просто: они лежат в пакете `JSON` ровно в том же виде, в каком нам экспортируются.

```perl
use JSON ();
JSON::decode_json('["str"]'); # works!
```

Сбор экспорта
-------------

Автор модуля мог поступить изощренней и генерировать экспортируемые функции в момент экспорта (нечто подобное нужно сделать в домашней работе _getset_). В этом случае простое погашение экспорта с помощью пустых скобок может не сработать — мы навсегда потеряем доступ к требуемым функциям.

Для этого можно использовать специальный промежуточный пакет, который соберет все экспортируемые функции и предоставит к ним свой интерфейс.

```
package My::JSON::Subs;
use JSON;
use Exporter 'import';
our @EXPORT_OK = qw(encode_json decode_json to_json from_json);
```

```perl
use My::JSON::Subs qw(encode_json);

encode_json({}); # works!
decode_json('{}'); # undefined</code>
```

Тут все просто: `JSON` безусловно экспортирует все фукнции в `My::JSON::Subs`, а `My::JSON::Subs` экспортирует только то, что требуется (благодаря `@EXPORT_OK`).

Сложный случай
--------------

В своей практике я сталкивался с конфликтом между модулями <i>Moose</i> и <i>Error</i> (оба достаточно популярны). Оба они экспортируют функцию с именем `with` (которая используется в качестве «ключевого слова»).

Moose:

```perl
use My::Module;
use Moose;
with 'My::Roles::Writable'; # with здесь подключает миксин
```

Error:

```perl
try {
    do_some_stuff();
}
catch Error::IO with { # with используется как ключевое слово для catch-блока
    # ...
}
```

Оба этих модуля не предлагают никакой возможности конфигурации для экспортируемых имен. Оба модуля настолько широко использовались в коде, что в одночасье написать для них обертку не представлялось возможным.

В качестве решения был использован следующий подход: уже на стадии исполнения программы в пакет `Error` была добавлена функция `using`, которая просто вызывала `with`, а в списке экспортируемых функций `using` заменила `with`.

Теперь оставалось только автозаменой во всем проекте заменить использование `catch Something with` на `catch Something using`.

Последний пример не является ни рекомендацией, ни руководством к действию. Он просто призван проиллюстрировать проблемы, которые может вызывать неграмотное использование экспорта.
